// Package app provides the main application structure and orchestration for the remoteweather system.
package app

import (
	"context"
	"fmt"
	"os"
	"os/signal"
	"sync"
	"syscall"

	"github.com/chrissnell/remoteweather/internal/controllers/management"
	"github.com/chrissnell/remoteweather/internal/log"
	"github.com/chrissnell/remoteweather/internal/managers"
	"github.com/chrissnell/remoteweather/pkg/config"
	"go.uber.org/zap"
)

// App represents the main application
type App struct {
	configProvider       config.ConfigProvider
	logger               *zap.SugaredLogger
	storageManager       *managers.StorageManager
	weatherManager       managers.WeatherStationManager
	controllerManager    managers.ControllerManager
	managementController *management.Controller // Direct reference to management controller
	ctx                  context.Context        // App context for dynamic operations
	wg                   *sync.WaitGroup        // App wait group for dynamic operations
}

// New creates a new application instance
func New(configProvider config.ConfigProvider, logger *zap.SugaredLogger) *App {
	return &App{
		configProvider: configProvider,
		logger:         logger,
	}
}

// Run starts the application and blocks until shutdown
func (a *App) Run(ctx context.Context, enableManagementAPI bool) error {
	var wg sync.WaitGroup
	var err error

	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	// Store context and wait group for dynamic operations
	a.ctx = ctx
	a.wg = &wg

	// Initialize the storage manager
	a.storageManager, err = managers.NewStorageManager(ctx, &wg, a.configProvider)
	if err != nil {
		return err
	}

	// Initialize the weather station manager
	a.weatherManager, err = managers.NewWeatherStationManager(ctx, &wg, a.configProvider, a.storageManager.ReadingDistributor, a.logger)
	if err != nil {
		return err
	}
	go a.weatherManager.StartWeatherStations()

	// Initialize the controller manager
	a.controllerManager, err = managers.NewControllerManager(ctx, &wg, a.configProvider, a.logger, a)
	if err != nil {
		return err
	}
	err = a.controllerManager.StartControllers()
	if err != nil {
		return err
	}

	// Create and start management controller
	cfgData, err := a.configProvider.LoadConfig()
	if err != nil {
		return err
	}

	// Find management controller configuration
	managementFound := false
	for _, controller := range cfgData.Controllers {
		if controller.Type == "management" && controller.ManagementAPI != nil {
			a.managementController, err = management.NewController(ctx, &wg, a.configProvider, *controller.ManagementAPI, a.logger, a)
			if err != nil {
				return err
			}
			err = a.managementController.StartController()
			if err != nil {
				return err
			}
			managementFound = true
			break
		}
	}

	// If --enable-management-api flag is set and no management controller exists, bootstrap it
	if enableManagementAPI && !managementFound {
		a.logger.Info("Management API flag enabled, bootstrapping management controller with default configuration...")

		// Create default management API configuration
		defaultConfig := config.ManagementAPIData{
			Port:       8081,
			ListenAddr: "127.0.0.1",
			// Token will be generated by the management controller
		}

		a.managementController, err = management.NewController(ctx, &wg, a.configProvider, defaultConfig, a.logger, a)
		if err != nil {
			return err
		}
		err = a.managementController.StartController()
		if err != nil {
			return err
		}

		a.logger.Info("Management API bootstrapped successfully with default configuration")
	}

	log.Info("Application started successfully")

	// Set up signal handling
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

	// Wait for shutdown signal
	select {
	case <-sigs:
		log.Info("shutdown signal received, initiating graceful shutdown...")
	case <-ctx.Done():
		log.Info("context cancelled, shutting down...")
	}

	// Cancel context to signal all goroutines to stop
	cancel()

	// Wait for all workers to terminate
	log.Info("waiting for all workers to terminate...")
	wg.Wait()
	log.Info("shutdown complete")

	return nil
}

// ReloadConfiguration reloads configuration across all managers
func (a *App) ReloadConfiguration(ctx context.Context) error {
	a.logger.Info("Reloading configuration across all managers...")

	var wg sync.WaitGroup

	// Reload storage configuration
	if err := a.storageManager.ReloadStorageConfig(ctx, &wg, a.configProvider); err != nil {
		a.logger.Errorf("Failed to reload storage configuration: %v", err)
		return err
	}

	// Reload weather station configuration
	if err := a.weatherManager.ReloadWeatherStationsConfig(); err != nil {
		a.logger.Errorf("Failed to reload weather station configuration: %v", err)
		return err
	}

	// Reload controller configuration
	if err := a.controllerManager.ReloadControllersConfig(); err != nil {
		a.logger.Errorf("Failed to reload controller configuration: %v", err)
		return err
	}

	a.logger.Info("Configuration reloaded successfully")
	return nil
}

// ReloadWebsiteConfiguration reloads website configuration for the REST controller
func (a *App) ReloadWebsiteConfiguration() error {
	a.logger.Info("Reloading website configuration...")

	// Use a type assertion to access the ReloadWebsiteConfiguration method
	type WebsiteReloader interface {
		ReloadWebsiteConfiguration() error
	}

	if websiteReloader, ok := a.controllerManager.(WebsiteReloader); ok {
		return websiteReloader.ReloadWebsiteConfiguration()
	}

	return fmt.Errorf("controller manager does not support website configuration reloading")
}

// AddController adds a new controller dynamically
func (a *App) AddController(controllerConfig *config.ControllerData) error {
	a.logger.Infof("Adding controller: %s", controllerConfig.Type)

	// Handle management controller separately
	if controllerConfig.Type == "management" && controllerConfig.ManagementAPI != nil {
		if a.managementController != nil {
			return fmt.Errorf("management controller already exists")
		}

		var err error
		a.managementController, err = management.NewController(a.ctx, a.wg, a.configProvider, *controllerConfig.ManagementAPI, a.logger, a)
		if err != nil {
			return err
		}
		return a.managementController.StartController()
	}

	// Handle regular controllers through controller manager
	return a.controllerManager.AddController(*controllerConfig)
}

// RemoveController removes a controller dynamically
func (a *App) RemoveController(controllerType string) error {
	a.logger.Infof("Removing controller: %s", controllerType)

	// Handle management controller separately
	if controllerType == "management" {
		if a.managementController == nil {
			return fmt.Errorf("management controller not found")
		}

		// Note: We can't cleanly stop the management controller since it doesn't have a Stop method
		// The context cancellation on app shutdown will handle cleanup
		a.managementController = nil
		a.logger.Infof("Management controller marked for removal (will stop on app shutdown)")
		return nil
	}

	// Handle regular controllers through controller manager
	return a.controllerManager.RemoveController(controllerType)
}

// AddWeatherStation adds a new weather station dynamically
func (a *App) AddWeatherStation(deviceName string) error {
	a.logger.Infof("Adding weather station: %s", deviceName)
	return a.weatherManager.AddWeatherStation(deviceName)
}

// RemoveWeatherStation removes a weather station dynamically
func (a *App) RemoveWeatherStation(deviceName string) error {
	a.logger.Infof("Removing weather station: %s", deviceName)
	return a.weatherManager.RemoveWeatherStation(deviceName)
}
