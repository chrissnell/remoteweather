// Weather Dashboard JavaScript
// Based on remoteweather.js.tmpl with modifications for new layout

// Global chart objects
let humidityChart, temperatureChart, barometerChart, snowdepthChart, windspeedChart, 
    winddirectionChart, rainfallChart, solarwattsChart, voltageChart;

// Timer variables  
let liveDataTimer;
let chartRefreshTimer;
let secondsSinceLastUpdate = 0;

// Constants
const LIVE_DATA_REFRESH_INTERVAL = 3500; // 3.5 seconds
const CHART_REFRESH_INTERVAL = 300000; // 5 minutes
const FORECAST_REFRESH_INTERVAL = 1000 * 60 * 60 * 4; // 4 hours
const MAX_POINTS = 20;

// Current chart range
let currentRange = '24h';

// Current forecast type
let currentForecastType = 'week';

// Debug flag
const debug = new URLSearchParams(window.location.search).get('debug') === '1';

// DOM element cache for performance
const domCache = new Map();

// Optimized DOM element accessor with caching
function getCachedElement(elementId) {
    if (!domCache.has(elementId)) {
        const element = document.getElementById(elementId);
        if (element) {
            domCache.set(elementId, element);
        } else if (debug) {
            console.warn(`Element not found: ${elementId}`);
        }
    }
    return domCache.get(elementId);
}

// Chart tab configuration
let chartTabList = {
    "24h": {
        "graphDivSuffix": "24h",
        "elementIdVal": "tab-24h",
        "spanHours": 24
    },
    "72h": {
        "graphDivSuffix": "72h",
        "elementIdVal": "tab-72h",
        "spanHours": 72
    },
    "7d": {
        "graphDivSuffix": "7d",
        "elementIdVal": "tab-7d",
        "spanHours": 168
    },
    "30d": {
        "graphDivSuffix": "30d",
        "elementIdVal": "tab-30d",
        "spanHours": 744
    },
    "1y": {
        "graphDivSuffix": "1y",
        "elementIdVal": "tab-1y",
        "spanHours": 8760
    }
};

// Get CSS variables for theming
function getCSSVariable(name) {
    return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

// Chart configuration object
let chartList = {
    "temperature": {
        "chart": temperatureChart,
        "divId": "temperatureChart",
        "yAxisLabel": "Degrees F",
        "chartType": "spline",
        "pointName": "outsideTempPoint",
        "initialSeries": [],
        "rendered": false
    },
    "humidity": {
        "chart": humidityChart,
        "divId": "humidityChart",
        "yAxisLabel": "Percent",
        "chartType": "spline",
        "pointName": "outsideHumidityPoint",
        "initialSeries": [],
        "rendered": false
    },
    {{ if .SnowEnabled }}
    "snowdepth": {
        "chart": snowdepthChart,
        "divId": "snowChart",
        "yAxisLabel": "inches",
        "chartType": "spline",
        "pointName": "snowdepthPoint",
        "initialSeries": [],
        "rendered": false
    },
    {{ end }}
    "barometer": {
        "chart": barometerChart,
        "divId": "barometerChart",
        "yAxisLabel": "inches Hg",
        "chartType": "spline",
        "pointName": "barometerPoint",
        "initialSeries": [],
        "rendered": false
    },
    "windspeed": {
        "chart": windspeedChart,
        "divId": "windspeedChart",
        "yAxisLabel": "MPH",
        "chartType": "spline",
        "pointName": "windSpeedPoint",
        "initialSeries": [],
        "rendered": false
    },
    "winddirection": {
        "chart": winddirectionChart,
        "divId": "winddirectionChart",
        "yAxisLabel": "",
        "chartType": "vector",
        "pointName": "windDirectionVectorPoint",
        "initialSeries": [],
        "rendered": false
    },
    "rainfall": {
        "chart": rainfallChart,
        "divId": "rainfallChart",
        "yAxisLabel": "Inches",
        "chartType": "column",
        "pointName": "rainfallPoint",
        "initialSeries": [],
        "rendered": false
    },
    "solarwatts": {
        "chart": solarwattsChart,
        "divId": "solarChart",
        "yAxisLabel": "Watts/m²",
        "chartType": "spline",
        "pointName": "solarWattsPoint",
        "initialSeries": [],
        "rendered": false,
        "additionalSeries": [{
            name: "Maximum Potential Solar Radiation",
            data: [],
            color: 'rgb(255, 81, 0)' // Will be overridden by CSS variable in createChart
        }]
    },
    "voltage": {
        "chart": voltageChart,
        "divId": "voltageChart",
        "yAxisLabel": "Volts",
        "chartType": "spline",
        "pointName": "voltagePoint",
        "initialSeries": [],
        "rendered": false
    }
};

// DOM ready
document.addEventListener('DOMContentLoaded', function() {
    initializeWeatherDashboard();
});

function initializeWeatherDashboard() {
    // Set up chart tab event listeners
    setupChartTabs();
    
    // Set up forecast tab event listeners
    setupForecastTabs();
  
    // Start data refresh cycles
    startLiveDataRefresh();
  
    // Load initial data
    loadInitialData();
}

function setupChartTabs() {
    const tabs = document.querySelectorAll('.chart-tab');
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const range = this.dataset.range;
            if (range !== currentRange) {
                switchChartRange(range);
            }
        });
    });
}

function setupForecastTabs() {
    const tabs = document.querySelectorAll('.forecast-tab');
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const forecastType = this.dataset.forecastType;
            if (forecastType !== currentForecastType) {
                switchForecastType(forecastType);
            }
        });
    });
}

function switchChartRange(range) {
    // Update active tab
    document.querySelectorAll('.chart-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelector(`[data-range="${range}"]`).classList.add('active');
  
    // Hide all chart containers
    document.querySelectorAll('.chart-range-container').forEach(container => {
        container.style.display = 'none';
    });
  
    // Show selected range container
    const targetContainer = document.getElementById(`charts-${range}`);
    if (targetContainer) {
        targetContainer.style.display = 'block';
    }
  
    currentRange = range;
  
    // Clear existing charts and load new ones
    clearCharts();
    fetchAndCreateCharts(range);
}

function switchForecastType(forecastType) {
    // Update active tab
    document.querySelectorAll('.forecast-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelector(`[data-forecast-type="${forecastType}"]`).classList.add('active');
  
    // Hide all forecast containers
    document.querySelectorAll('.forecast-container').forEach(container => {
        container.style.display = 'none';
    });
  
    // Show selected forecast container
    const targetContainer = document.getElementById(`forecast-${forecastType}`);
    if (targetContainer) {
        targetContainer.style.display = 'block';
    }
  
    currentForecastType = forecastType;
}

function loadInitialData() {
    // Load live data first
    refreshLiveData();
  
    // Load initial chart range (24h)
    fetchAndCreateCharts('24h');
    
    // Load initial forecast data
    refreshWeekForecastData();
    refreshDayForecastData();
}

function startLiveDataRefresh() {
    if (liveDataTimer) {
        clearInterval(liveDataTimer);
    }
  
    liveDataTimer = setInterval(refreshLiveData, LIVE_DATA_REFRESH_INTERVAL);
}

// Fetch data with timeout
async function fetchWithTimeout(url, timeout = 10000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
        return response.json();
    } catch (error) {
        clearTimeout(timeoutId);
        if (debug) console.error(`Failed to fetch ${url}:`, error);
        return null;
    }
}

// Fetch data for a given tab and station
async function fetchData(tabKey, station) {
    return fetchWithTimeout(`/span/${chartTabList[tabKey].spanHours}h?station=${station}`);
}

// Process fetched data into chart series (exactly like original)
function processData(data, chartList) {
    if (!data || !Array.isArray(data)) return;
    
    const modVal = Math.max(1, Math.floor(data.length / 50));
    const dataLength = data.length;
    
    // Pre-allocate arrays for better performance
    chartList.temperature.initialSeries = new Array(dataLength);
    chartList.humidity.initialSeries = new Array(dataLength);
    chartList.barometer.initialSeries = new Array(dataLength);
    chartList.windspeed.initialSeries = new Array(dataLength);
    chartList.rainfall.initialSeries = new Array(dataLength);
    chartList.voltage.initialSeries = new Array(dataLength);
    chartList.solarwatts.initialSeries = new Array(dataLength);
    
    if (chartList.solarwatts.additionalSeries) {
        chartList.solarwatts.additionalSeries[0].data = new Array(dataLength);
    }
    
    let windDirectionIndex = 0;
    chartList.winddirection.initialSeries = [];
    
    {{ if .SnowEnabled }}
    chartList.snowdepth.initialSeries = new Array(dataLength);
    {{ end }}
    
    // Single loop to process all data
    for (let i = 0; i < dataLength; i++) {
        const item = data[i];
        const ts = item.ts;
        
        chartList.temperature.initialSeries[i] = [ts, item.otemp];
        chartList.humidity.initialSeries[i] = [ts, item.outhumidity];
        chartList.barometer.initialSeries[i] = [ts, item.bar];
        chartList.windspeed.initialSeries[i] = [ts, item.winds];
        chartList.rainfall.initialSeries[i] = [ts, item.period_rain];
        chartList.voltage.initialSeries[i] = [ts, item.stationbatteryvoltage];
        chartList.solarwatts.initialSeries[i] = [ts, item.solarwatts];
        
        {{ if .SnowEnabled }}
        chartList.snowdepth.initialSeries[i] = [ts, item.snowdepth];
        {{ end }}
        
        if (chartList.solarwatts.additionalSeries) {
            chartList.solarwatts.additionalSeries[0].data[i] = [ts, item.potentialsolarwatts];
        }
        
        if (i % modVal === 0 || dataLength < 50) {
            chartList.winddirection.initialSeries.push([ts, 0, item.winds, item.windd]);
        }
    }
}

// Create charts for all metrics (parallelized)
function createCharts(tabKey, chartList) {
    const chartPromises = [];
    
    for (let key in chartList) {
        const chartElement = getCachedElement(`${chartList[key].divId}${chartTabList[tabKey].graphDivSuffix}`);
        if (chartElement) {
            const options = {
                yAxisTitle: chartList[key].yAxisLabel,
                chartType: chartList[key].chartType,
                tooltipFormat: chartList[key].chartType === 'vector' ? {
                    pointFormat: '{date point.x}<br/>Speed: <b>{point.length:.1f} MPH</b><br/>Direction: <b>{point.direction:.0f}\u00B0</b>'
                } : { valueDecimals: 2 },
                ...(chartList[key].additionalSeries ? { additionalSeries: chartList[key].additionalSeries } : {})
            };
            
            // Create charts in parallel using requestAnimationFrame for better performance
            chartPromises.push(new Promise(resolve => {
                requestAnimationFrame(() => {
                    chartList[key].chart = createChart(key, chartElement, chartList[key].initialSeries, chartList[key].title, options);
                    resolve();
                });
            }));
        }
    }
    
    return Promise.all(chartPromises);
}

// Fetch data and create charts for a tab (optimized with parallel requests)
async function fetchAndCreateCharts(tabKey) {
    const fetchPromises = [
        fetchData(tabKey, '{{ .PullFromDevice }}')
    ];
    
    {{- if .SnowEnabled }}
    fetchPromises.push(fetchData(tabKey, '{{ .SnowDevice }}'));
    {{- end }}
    
    try {
        const results = await Promise.all(fetchPromises);
        const [data, snowData] = results;
        
        if (!data) return;
        
        processData(data, chartList);
        
        {{- if .SnowEnabled }}
        // Process snow data separately if available
        if (snowData && Array.isArray(snowData)) {
            chartList.snowdepth.initialSeries = [];
            snowData.forEach(item => {
                chartList.snowdepth.initialSeries.push([item.ts, item.snowdepth]);
            });
        }
        {{- end }}
        
        await createCharts(tabKey, chartList);
        
    } catch (error) {
        if (debug) console.error('Error fetching and creating charts:', error);
    }
}

// Generic chart creation function (exactly like original)
function createChart(chartName, targetDiv, data, title, options = {}) {
    const { yAxisTitle, chartType = 'spline', tooltipFormat, additionalSeries = [] } = options;
    
    // Get CSS variables for theming
    const getCSSVariable = (name) => {
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    };
    
    const config = {
        chart: {
            type: chartType,
            backgroundColor: getCSSVariable('--chart-bg'),
            style: { 
                fontFamily: 'Inconsolata, Roboto, sans-serif',
                color: getCSSVariable('--chart-text')
            },
            events: { load: () => markAsRendered(chartName) }
        },
        title: { 
            text: title,
            style: { color: getCSSVariable('--chart-text') }
        },
        credits: { enabled: false },
        legend: { 
            enabled: additionalSeries.length > 0,
            itemStyle: { color: getCSSVariable('--chart-text') }
        },
        xAxis: {
            type: 'datetime',
            dateTimeLabelFormats: { hour: '%l %p', minute: '%I:%M %p' },
            lineColor: getCSSVariable('--chart-grid'),
            tickColor: getCSSVariable('--chart-grid'),
            labels: { style: { color: getCSSVariable('--chart-text') } }
        },
        yAxis: chartType === 'vector' ? { visible: false } : { 
            title: { 
                text: yAxisTitle,
                style: { color: getCSSVariable('--chart-text') }
            },
            gridLineColor: getCSSVariable('--chart-grid'),
            labels: { style: { color: getCSSVariable('--chart-text') } }
        },
        time: { useUTC: false },
        tooltip: {
            backgroundColor: getCSSVariable('--chart-tooltip-bg'),
            borderColor: getCSSVariable('--chart-tooltip-border'),
            style: { color: getCSSVariable('--chart-text') },
            ...(tooltipFormat || {})
        },
        series: [
            {
                name: title,
                data,
                color: getCSSVariable('--chart-series-color'),
                marker: {
                    enabled: false,
                    states: {
                        hover: {
                            enabled: true,
                            radius: 3
                        }
                    }
                }
            },
            ...additionalSeries.map(series => ({
                ...series,
                color: getCSSVariable('--chart-series-color-alt')
            }))
        ]
    };
    return Highcharts.chart(targetDiv, config);
}

// Mark a chart as rendered
async function markAsRendered(chartName) {
    chartList[chartName].rendered = true;
}

// Clear all charts
function clearCharts() {
    for (let key in chartList) {
        if (chartList[key].chart && chartList[key].chart.destroy) {
            chartList[key].chart.destroy();
            chartList[key].chart = null;
            chartList[key].rendered = false;
        }
    }
}

// Refresh charts for theme change
function refreshChartsForTheme() {
    // Clear existing charts
    clearCharts();
    
    // Recreate charts for current range
    if (currentRange) {
        fetchAndCreateCharts(currentRange);
    }
}

// Make function globally available
window.refreshChartsForTheme = refreshChartsForTheme;

function refreshLiveData() {
    const fetchPromises = [fetch('/latest').then(response => response.json())];
    
    {{ if .SnowEnabled }}
    fetchPromises.push(fetch('/snow').then(response => response.json()));
    {{ end }}
    
    Promise.all(fetchPromises)
        .then(results => {
            const [weatherData, snowData] = results;
            if (weatherData) {
                updateLiveReadings(weatherData, snowData);
                updateLiveIndicator();
            }
        })
        .catch(error => {
            if (debug) console.error('Error fetching live data:', error);
            updateLiveIndicator(false);
        });
}

function updateLiveReadings(data, snowData = null) {
    // Temperature & Atmospheric
    updateElement('temperature', formatTemperatureValue(data.otemp));
    
    // Calculate feels-like temperature with debugging
    let feelsLike = data.heatidx || data.windch || data.otemp;
    if (debug) {
        console.log('Feels-like debug:', {
            heatidx: data.heatidx,
            windch: data.windch,
            otemp: data.otemp,
            calculated: feelsLike
        });
    }
    updateElement('feels-like', formatTemperatureValue(feelsLike));
    
    updateElement('humidity', `${data.ohum ? parseFloat(data.ohum).toFixed(1) : '--'}`);
    updateElement('dew-point', formatTemperatureValue(calculateDewPoint(data.otemp, data.ohum)));
    updateElement('barometer', `${data.bar ? parseFloat(data.bar).toFixed(2) : '--'}`);
    updateElement('solar', `${data.solarwatts ? parseFloat(data.solarwatts).toFixed(1) : '--'}`);
    
    // Sky conditions with debugging
    const skyCondition = calculateSkyConditions(data.solarwatts, data.potentialsolarwatts);
    if (debug) {
        console.log('Sky conditions calculation:', {
            solarwatts: data.solarwatts,
            potentialsolarwatts: data.potentialsolarwatts,
            result: skyCondition
        });
    }
    updateElement('sky-conditions', skyCondition);
  
    // Wind
    updateElement('wind-speed', `${data.winds ? Math.round(parseFloat(data.winds)) : '--'}`);
    updateElement('wind-gusts', `${data.windgust ? Math.round(parseFloat(data.windgust)) : '--'}`);
    updateElement('wind-direction', data.windcard || '--');
    updateElement('wind-degrees', `(${data.windd || '--'}°)`);
  
    // Update windrose - original implementation
    updateWindrose(data.windd, data.winds, data.windcard);
  
    // Precipitation
    updateElement('rain-today', `${data.dayrain !== null && data.dayrain !== undefined ? parseFloat(data.dayrain).toFixed(2) : '--'}`);
    updateElement('rain-rate', `${data.rainrate !== null && data.rainrate !== undefined ? parseFloat(data.rainrate).toFixed(2) : '--'}`);
    
    // Rainfall totals
    updateElement('rain-24hr', `${data.rainfall24h !== null && data.rainfall24h !== undefined ? parseFloat(data.rainfall24h).toFixed(2) : '--'}`);
    updateElement('rain-48hr', `${data.rainfall48h !== null && data.rainfall48h !== undefined ? parseFloat(data.rainfall48h).toFixed(2) : '--'}`);
    updateElement('rain-72hr', `${data.rainfall72h !== null && data.rainfall72h !== undefined ? parseFloat(data.rainfall72h).toFixed(2) : '--'}`);
    updateElement('rain-storm-total', `${data.rainfallstorm !== null && data.rainfallstorm !== undefined ? parseFloat(data.rainfallstorm).toFixed(2) : '--'}`);
  
          {{ if .SnowEnabled }}
      // Snow data - use snowData parameter from /snow endpoint
      if (snowData) {
        updateElement('snow-depth', `${(snowData.snowdepth !== null && snowData.snowdepth !== undefined) ? parseFloat(snowData.snowdepth).toFixed(2) : '0.00'}`);
        updateElement('snow-24hr', `${(snowData.snowlast24 !== null && snowData.snowlast24 !== undefined) ? parseFloat(snowData.snowlast24).toFixed(2) : '0.00'}`);
        updateElement('snow-72hr', `${(snowData.snowlast72 !== null && snowData.snowlast72 !== undefined) ? parseFloat(snowData.snowlast72).toFixed(2) : '0.00'}`);
        updateElement('snow-storm-total', `${(snowData.snowstorm !== null && snowData.snowstorm !== undefined) ? parseFloat(snowData.snowstorm).toFixed(2) : '0.00'}`);
        // Use server-calculated snowfall rate if available, otherwise calculate manually
        let accumulationRate = '0.00';
        if (snowData.snowfallrate !== undefined && snowData.snowfallrate !== null && snowData.snowfallrate > 0) {
          accumulationRate = parseFloat(snowData.snowfallrate).toFixed(3);
        } else if (snowData.snowlast24 && snowData.snowlast24 > 0) {
          // Fallback: calculate rate from 24-hour total
          accumulationRate = (snowData.snowlast24 / 24).toFixed(3);
        }
        updateElement('snow-accumulation-rate', accumulationRate);
      } else {
        // No snow data available, show default values
        updateElement('snow-depth', '0.00');
        updateElement('snow-24hr', '0.00');
        updateElement('snow-72hr', '0.00');
        updateElement('snow-storm-total', '0.00');
        updateElement('snow-accumulation-rate', '0.00');
      }
      {{ end }}
  
    // Battery Status (now in header)
    updateBatteryInfo(data.stationbatteryvoltage);
}

function updateElement(id, value) {
    const element = document.getElementById(id);
    if (element) {
        // Use innerHTML if value contains HTML tags, otherwise use textContent
        if (typeof value === 'string' && value.includes('<')) {
            element.innerHTML = value;
        } else {
            element.textContent = value;
        }
        if (debug && id === 'feels-like') {
            console.log('Updated feels-like element:', { id, value, element });
        }
    } else {
        if (debug) {
            console.warn('Element not found:', id);
        }
    }
}

function formatTemperature(temp) {
    return temp != null ? `${Math.round(parseFloat(temp))}°F` : '--°F';
}

function formatTemperatureValue(temp) {
    return temp != null ? `${Math.round(parseFloat(temp))}` : '--';
}

function calculateDewPoint(temp, humidity) {
    if (!temp || !humidity) return null;
    const t = parseFloat(temp);
    const h = parseFloat(humidity);
    const a = 17.27;
    const b = 237.7;
    const alpha = ((a * t) / (b + t)) + Math.log(h / 100.0);
    return (b * alpha) / (a - alpha);
}

function calculateSolarPercent(current, max) {
    if (!current || !max || parseFloat(max) === 0) return '--';
    return Math.round((parseFloat(current) / parseFloat(max)) * 100);
}

function calculateSkyConditions(current, max) {
    // Handle null/undefined values
    if (current === null || current === undefined || max === null || max === undefined) {
        return '--';
    }
    
    const currentValue = parseFloat(current);
    const maxValue = parseFloat(max);
    
    // Handle NaN values
    if (isNaN(currentValue) || isNaN(maxValue)) {
        return '--';
    }
    
    // If potential solar is very low, it's night
    if (maxValue < 10) return 'Night';
    
    // Handle zero max value to avoid division by zero
    if (maxValue === 0) return 'Night';
    
    // Calculate percentage
    const percentage = (currentValue / maxValue) * 100;
    
    if (debug) {
        console.log('Sky conditions debug:', {
            current: currentValue,
            max: maxValue,
            percentage: percentage
        });
    }
    
    if (percentage >= 80) return 'Sunny';
    if (percentage >= 40) return 'Partly Cloudy';
    return 'Cloudy';
}

function getBatteryStatus(voltage) {
    if (!voltage) return '--';
    const v = parseFloat(voltage);
    if (v >= 12.6) return 'Good';
    if (v >= 12.0) return 'Fair';
    return 'Low';
}

function updateBatteryInfo(voltage) {
    const batteryInfoElement = document.getElementById('battery-info');
    const batteryVoltageElement = document.getElementById('battery-voltage');
    const batteryStatusElement = document.getElementById('battery-status');
    
    if (!voltage || parseFloat(voltage) === 0) {
        // Hide battery info if voltage is null, undefined, or 0
        if (batteryInfoElement) {
            batteryInfoElement.style.display = 'none';
        }
    } else {
        // Show battery info with voltage and status
        const v = parseFloat(voltage);
        if (batteryInfoElement) {
            batteryInfoElement.style.display = 'block';
        }
        if (batteryVoltageElement) {
            batteryVoltageElement.textContent = v.toFixed(2);
        }
        if (batteryStatusElement) {
            batteryStatusElement.textContent = getBatteryStatus(voltage);
        }
    }
}

function updateWindrose(direction, speed, cardinalDir) {
    // Update the windrose circle rotation (original implementation)
    const windDirElement = document.getElementById('rdg-winddir');
    if (windDirElement && direction != null) {
        windDirElement.style.transform = `rotate(${direction}deg)`;
    }
    
    // Update the cardinal direction display
    const cardinalElement = document.getElementById('rdg-winddir-cardinal');
    if (cardinalElement) {
        cardinalElement.textContent = cardinalDir || '---';
    }
    
    // Update the wind speed display in the windrose
    const speedElement = document.getElementById('rdg-windspeed');
    if (speedElement) {
        speedElement.textContent = speed ? Math.round(parseFloat(speed)) : '--';
    }
}

function updateLiveIndicator(isLive = true) {
    const indicatorDot = document.getElementById('live-indicator-dot');
    const update = document.getElementById('last-update');
  
    if (indicatorDot) {
        if (isLive) {
            // Show green flashing dot
            indicatorDot.style.display = 'flex';
            indicatorDot.style.animation = 'livePulse 2s infinite';
        } else {
            // Show dimmed/offline state
            indicatorDot.style.animation = 'none';
            indicatorDot.style.opacity = '0.3';
            indicatorDot.style.backgroundColor = '#666';
        }
    }
  
    if (update) {
        if (isLive) {
            secondsSinceLastUpdate = 0;
            update.textContent = 'Last updated 0s ago';
        } else {
            update.textContent = 'Update failed';
        }
    }
}

// Increment timer for last updated display
function incrementUpdateTimer() {
    secondsSinceLastUpdate++;
    const updateElement = document.getElementById('last-update');
    if (updateElement) {
        updateElement.textContent = `Last updated ${secondsSinceLastUpdate}s ago`;
    }
}

// Error handling
window.addEventListener('error', function(e) {
    if (debug) {
        console.error('Weather dashboard error:', e.error);
    }
});

// Visibility change handling - refresh when page becomes visible
document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        refreshLiveData();
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (liveDataTimer) {
        clearInterval(liveDataTimer);
    }
    clearCharts();
});

// Forecast data functions
async function refreshWeekForecastData() {
    if (debug) console.log("Fetching week forecast data...");
    try {
        const data = await fetchWithTimeout('/forecast/168');
        if (!data) {
            setTimeout(refreshWeekForecastData, 60000);
            return;
        }
        
        if (debug) console.log("Week forecast data received:", data);

        const dayToDayName = {
            0: "Sunday", 1: "Monday", 2: "Tuesday", 3: "Wednesday",
            4: "Thursday", 5: "Friday", 6: "Saturday", 7: "Sunday"
        };

        // Batch DOM updates
        requestAnimationFrame(() => {
            let i = 0;
            for (const interval of data.data) {
                let intervalDate = new Date(interval.dateTimeISO);
                let dateLabel = i === 0 ? "Today" : dayToDayName[intervalDate.getDay()];
                
                updateElement(`week-forecast-interval-${i}-title`, dateLabel);
                updateElement(`week-forecast-interval-${i}-high-temp`, interval.maxTempF);
                updateElement(`week-forecast-interval-${i}-low-temp`, interval.minTempF);
                updateElement(`week-forecast-interval-${i}-icon`, interval.weatherIcon);
                updateElement(`week-forecast-interval-${i}-weather`, interval.compactWeather);

                const snowRegex = /.*:.*:(S|SW|SI|RS|WM|BS)$/g;
                const snow = snowRegex.test(interval.weatherPrimaryCoded);
                const rainRegex = /.*:.*:(R|RW|T|TO|UP|ZR|L|BY|ZY|ZR)$/g;
                const rain = rainRegex.test(interval.weatherPrimaryCoded);

                if (snow) {
                    if (debug) console.log(`Week forecast interval ${i} - snow: `, interval.snowIN);
                    updateElement(`week-forecast-interval-${i}-precip-icon`, "❄");
                    updateElement(`week-forecast-interval-${i}-precip`, interval.snowIN + "\"");
                } else if (rain) {
                    if (debug) console.log(`Week forecast interval ${i} - rain: `, interval.precipIN);
                    updateElement(`week-forecast-interval-${i}-precip-icon`, "⛆");
                    updateElement(`week-forecast-interval-${i}-precip`, interval.precipIN + "\"");
                } else {
                    if (debug) console.log(`Week forecast interval ${i} - no precip`);
                    updateElement(`week-forecast-interval-${i}-precip-icon`, "");
                    updateElement(`week-forecast-interval-${i}-precip`, "");
                }
                i++;
            }

            const lastUpdated = moment(data.lastUpdated, "YYYY-MM-DD HH:mm:ss.SSSSSS-ZZ").format("h:mm A, DD MMM YYYY");
            updateElement('forecast-week-last-updated', "Last Updated: " + lastUpdated);
        });

        setTimeout(refreshWeekForecastData, FORECAST_REFRESH_INTERVAL);
    } catch (error) {
        if (debug) console.error("Failed to fetch week forecast data:", error);
        setTimeout(refreshWeekForecastData, 60000); // Retry in 1 minute
    }
}

async function refreshDayForecastData() {
    if (debug) console.log("Fetching day forecast data...");
    try {
        const data = await fetchWithTimeout('/forecast/24');
        if (!data) {
            setTimeout(refreshDayForecastData, 60000);
            return;
        }
        
        if (debug) console.log("Day forecast data received:", data);

        // Pre-calculate temperature scaling (matching original algorithm)
        let pixelsPerDegree = 0;
        const tempSpreadPixels = 80;
        const avgTemps = data.data.map((x) => x.avgTempF);
        const lowTemp = Math.min.apply(null, avgTemps);
        const highTemp = Math.max.apply(null, avgTemps);
        const tempSpread = highTemp - lowTemp;
        if (tempSpread > 0) {
            pixelsPerDegree = tempSpreadPixels / tempSpread;
        }
        
        // Debug temperature distribution
        if (debug) {
            console.log("Temperature distribution debug:", {
                avgTemps,
                lowTemp,
                highTemp,
                tempSpread,
                pixelsPerDegree,
                tempSpreadPixels
            });
        }

        // Batch DOM updates
        requestAnimationFrame(() => {
            let i = 0;
            for (const interval of data.data) {
                let intervalDate = moment(interval.dateTimeISO, "YYYY-MM-DD HH:mm:ss.SSSSSS-ZZ");
                let dateLabel = (intervalDate.hour() === 0 || i === 0) 
                    ? intervalDate.format("h A") + "<br>" + intervalDate.format("ddd") 
                    : intervalDate.format("h A");
                
                updateElement(`day-forecast-interval-${i}-title`, dateLabel);
                updateElement(`day-forecast-interval-${i}-avg-temp`, interval.avgTempF + "°");
                updateElement(`day-forecast-interval-${i}-icon`, interval.weatherIcon);

                // Apply temperature-dependent vertical positioning
                const adjustableDiv = document.getElementById(`day-forecast-interval-${i}-adjustable-div`);
                if (adjustableDiv) {
                    const paddingValue = pixelsPerDegree * (highTemp - interval.avgTempF);
                    adjustableDiv.style.paddingTop = paddingValue + "px";
                    
                    // Debug individual temperature positioning
                    if (debug) {
                        console.log(`Interval ${i} temp positioning:`, {
                            temp: interval.avgTempF,
                            highTemp,
                            difference: highTemp - interval.avgTempF,
                            paddingValue,
                            paddingString: paddingValue + "px"
                        });
                    }
                }

                const snowRegex = /.*:.*:(S|SW|SI|RS|WM|BS)$/g;
                const snow = snowRegex.test(interval.weatherPrimaryCoded);
                const rainRegex = /.*:.*:(R|RW|T|TO|UP|ZR|L|BY|ZY|ZR)$/g;
                const rain = rainRegex.test(interval.weatherPrimaryCoded);

                if (snow) {
                    if (debug) console.log(`Day forecast interval ${i} - snow: `, interval.snowIN);
                    updateElement(`day-forecast-interval-${i}-precip-icon`, "❄");
                    updateElement(`day-forecast-interval-${i}-precip`, interval.snowIN + "\"");
                } else if (rain) {
                    if (debug) console.log(`Day forecast interval ${i} - rain: `, interval.precipIN);
                    updateElement(`day-forecast-interval-${i}-precip-icon`, "⛆");
                    updateElement(`day-forecast-interval-${i}-precip`, interval.precipIN + "\"");
                } else {
                    if (debug) console.log(`Day forecast interval ${i} - no precip`);
                    updateElement(`day-forecast-interval-${i}-precip-icon`, "");
                    updateElement(`day-forecast-interval-${i}-precip`, interval.pop + "%");
                }
                i++;
            }

            const lastUpdated = moment(data.lastUpdated, "YYYY-MM-DD HH:mm:ss.SSSSSS-ZZ").format("h:mm A, DD MMM YYYY");
            updateElement('forecast-day-last-updated', "Last Updated: " + lastUpdated);
        });

        setTimeout(refreshDayForecastData, FORECAST_REFRESH_INTERVAL);
    } catch (error) {
        if (debug) console.error("Failed to fetch day forecast data:", error);
        setTimeout(refreshDayForecastData, 60000); // Retry in 1 minute
    }
}

// Initialize the page
document.addEventListener('DOMContentLoaded', function() {
    // Start the update timer
    setInterval(incrementUpdateTimer, 1000);
    
    // Start live data refresh
    refreshLiveData();
    liveDataTimer = setInterval(refreshLiveData, LIVE_DATA_REFRESH_INTERVAL);
}); 