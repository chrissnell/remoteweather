// Weather Dashboard JavaScript
// Based on remoteweather.js.tmpl with modifications for new layout

// Global chart objects
let humidityChart, temperatureChart, barometerChart, snowdepthChart, windspeedChart, 
    winddirectionChart, rainfallChart, solarwattsChart, voltageChart;

// Timer variables  
let liveDataTimer;
let chartRefreshTimer;

// Constants
const LIVE_DATA_REFRESH_INTERVAL = 3500; // 3.5 seconds
const CHART_REFRESH_INTERVAL = 300000; // 5 minutes
const MAX_POINTS = 20;

// Current chart range
let currentRange = '24h';

// Debug flag
const debug = new URLSearchParams(window.location.search).get('debug') === '1';

// DOM element cache for performance
const domCache = new Map();

// Optimized DOM element accessor with caching
function getCachedElement(elementId) {
    if (!domCache.has(elementId)) {
        const element = document.getElementById(elementId);
        if (element) {
            domCache.set(elementId, element);
        } else if (debug) {
            console.warn(`Element not found: ${elementId}`);
        }
    }
    return domCache.get(elementId);
}

// Chart tab configuration
let chartTabList = {
    "24h": {
        "graphDivSuffix": "24h",
        "elementIdVal": "tab-24h",
        "spanHours": 24
    },
    "72h": {
        "graphDivSuffix": "72h",
        "elementIdVal": "tab-72h",
        "spanHours": 72
    },
    "7d": {
        "graphDivSuffix": "7d",
        "elementIdVal": "tab-7d",
        "spanHours": 168
    },
    "30d": {
        "graphDivSuffix": "30d",
        "elementIdVal": "tab-30d",
        "spanHours": 744
    },
    "1y": {
        "graphDivSuffix": "1y",
        "elementIdVal": "tab-1y",
        "spanHours": 8760
    }
};

// Chart configuration object
let chartList = {
    "temperature": {
        "chart": temperatureChart,
        "divId": "temperatureChart",
        "title": "Outside Temperature",
        "yAxisLabel": "Degrees F",
        "chartType": "spline",
        "pointName": "outsideTempPoint",
        "initialSeries": [],
        "rendered": false
    },
    "humidity": {
        "chart": humidityChart,
        "divId": "humidityChart",
        "title": "Humidity",
        "yAxisLabel": "Percent",
        "chartType": "spline",
        "pointName": "outsideHumidityPoint",
        "initialSeries": [],
        "rendered": false
    },
    {{ if .SnowEnabled }}
    "snowdepth": {
        "chart": snowdepthChart,
        "divId": "snowChart",
        "title": "Snow Depth",
        "yAxisLabel": "inches",
        "chartType": "spline",
        "pointName": "snowdepthPoint",
        "initialSeries": [],
        "rendered": false
    },
    {{ end }}
    "barometer": {
        "chart": barometerChart,
        "divId": "barometerChart",
        "title": "Barometer",
        "yAxisLabel": "inches Hg",
        "chartType": "spline",
        "pointName": "barometerPoint",
        "initialSeries": [],
        "rendered": false
    },
    "windspeed": {
        "chart": windspeedChart,
        "divId": "windspeedChart",
        "title": "Wind Speed",
        "yAxisLabel": "MPH",
        "chartType": "spline",
        "pointName": "windSpeedPoint",
        "initialSeries": [],
        "rendered": false
    },
    "winddirection": {
        "chart": winddirectionChart,
        "divId": "winddirectionChart",
        "title": "Wind Direction",
        "yAxisLabel": "",
        "chartType": "vector",
        "pointName": "windDirectionVectorPoint",
        "initialSeries": [],
        "rendered": false
    },
    "rainfall": {
        "chart": rainfallChart,
        "divId": "rainfallChart",
        "title": "Rainfall",
        "yAxisLabel": "Inches",
        "chartType": "column",
        "pointName": "rainfallPoint",
        "initialSeries": [],
        "rendered": false
    },
    "solarwatts": {
        "chart": solarwattsChart,
        "divId": "solarChart",
        "title": "Observed Solar Radiation",
        "yAxisLabel": "Watts/m²",
        "chartType": "spline",
        "pointName": "solarWattsPoint",
        "initialSeries": [],
        "rendered": false,
        "additionalSeries": [{
            name: "Maximum Potential Solar Radiation",
            data: [],
            color: '#FFA500' // Orange
        }]
    },
    "voltage": {
        "chart": voltageChart,
        "divId": "voltageChart",
        "title": "Station Battery Voltage",
        "yAxisLabel": "Volts",
        "chartType": "spline",
        "pointName": "voltagePoint",
        "initialSeries": [],
        "rendered": false
    }
};

// DOM ready
document.addEventListener('DOMContentLoaded', function() {
    initializeWeatherDashboard();
});

function initializeWeatherDashboard() {
    // Set up chart tab event listeners
    setupChartTabs();
  
    // Start data refresh cycles
    startLiveDataRefresh();
  
    // Load initial data
    loadInitialData();
}

function setupChartTabs() {
    const tabs = document.querySelectorAll('.chart-tab');
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const range = this.dataset.range;
            if (range !== currentRange) {
                switchChartRange(range);
            }
        });
    });
}

function switchChartRange(range) {
    // Update active tab
    document.querySelectorAll('.chart-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelector(`[data-range="${range}"]`).classList.add('active');
  
    // Hide all chart containers
    document.querySelectorAll('.chart-range-container').forEach(container => {
        container.style.display = 'none';
    });
  
    // Show selected range container
    const targetContainer = document.getElementById(`charts-${range}`);
    if (targetContainer) {
        targetContainer.style.display = 'block';
    }
  
    currentRange = range;
  
    // Clear existing charts and load new ones
    clearCharts();
    fetchAndCreateCharts(range);
}

function loadInitialData() {
    // Load live data first
    refreshLiveData();
  
    // Load initial chart range (24h)
    fetchAndCreateCharts('24h');
}

function startLiveDataRefresh() {
    if (liveDataTimer) {
        clearInterval(liveDataTimer);
    }
  
    liveDataTimer = setInterval(refreshLiveData, LIVE_DATA_REFRESH_INTERVAL);
}

// Fetch data with timeout
async function fetchWithTimeout(url, timeout = 10000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
        return response.json();
    } catch (error) {
        clearTimeout(timeoutId);
        if (debug) console.error(`Failed to fetch ${url}:`, error);
        return null;
    }
}

// Fetch data for a given tab and station
async function fetchData(tabKey, station) {
    return fetchWithTimeout(`/span/${chartTabList[tabKey].spanHours}h?station=${station}`);
}

// Process fetched data into chart series (exactly like original)
function processData(data, chartList) {
    if (!data || !Array.isArray(data)) return;
    
    const modVal = Math.max(1, Math.floor(data.length / 50));
    const dataLength = data.length;
    
    // Pre-allocate arrays for better performance
    chartList.temperature.initialSeries = new Array(dataLength);
    chartList.humidity.initialSeries = new Array(dataLength);
    chartList.barometer.initialSeries = new Array(dataLength);
    chartList.windspeed.initialSeries = new Array(dataLength);
    chartList.rainfall.initialSeries = new Array(dataLength);
    chartList.voltage.initialSeries = new Array(dataLength);
    chartList.solarwatts.initialSeries = new Array(dataLength);
    
    if (chartList.solarwatts.additionalSeries) {
        chartList.solarwatts.additionalSeries[0].data = new Array(dataLength);
    }
    
    let windDirectionIndex = 0;
    chartList.winddirection.initialSeries = [];
    
    {{ if .SnowEnabled }}
    chartList.snowdepth.initialSeries = new Array(dataLength);
    {{ end }}
    
    // Single loop to process all data
    for (let i = 0; i < dataLength; i++) {
        const item = data[i];
        const ts = item.ts;
        
        chartList.temperature.initialSeries[i] = [ts, item.otemp];
        chartList.humidity.initialSeries[i] = [ts, item.outhumidity];
        chartList.barometer.initialSeries[i] = [ts, item.bar];
        chartList.windspeed.initialSeries[i] = [ts, item.winds];
        chartList.rainfall.initialSeries[i] = [ts, item.period_rain];
        chartList.voltage.initialSeries[i] = [ts, item.stationbatteryvoltage];
        chartList.solarwatts.initialSeries[i] = [ts, item.solarwatts];
        
        {{ if .SnowEnabled }}
        chartList.snowdepth.initialSeries[i] = [ts, item.snowdepth];
        {{ end }}
        
        if (chartList.solarwatts.additionalSeries) {
            chartList.solarwatts.additionalSeries[0].data[i] = [ts, item.potentialsolarwatts];
        }
        
        if (i % modVal === 0 || dataLength < 50) {
            chartList.winddirection.initialSeries.push([ts, 5, item.winds, item.windd]);
        }
    }
}

// Create charts for all metrics (parallelized)
function createCharts(tabKey, chartList) {
    const chartPromises = [];
    
    for (let key in chartList) {
        const chartElement = getCachedElement(`${chartList[key].divId}${chartTabList[tabKey].graphDivSuffix}`);
        if (chartElement) {
            const options = {
                yAxisTitle: chartList[key].yAxisLabel,
                chartType: chartList[key].chartType,
                tooltipFormat: chartList[key].chartType === 'vector' ? {
                    pointFormat: '{date point.x}<br/>Speed: <b>{point.length:.1f} MPH</b><br/>Direction: <b>{point.direction:.0f}\u00B0</b>'
                } : { valueDecimals: 2 },
                ...(chartList[key].additionalSeries ? { additionalSeries: chartList[key].additionalSeries } : {})
            };
            
            // Create charts in parallel using requestAnimationFrame for better performance
            chartPromises.push(new Promise(resolve => {
                requestAnimationFrame(() => {
                    chartList[key].chart = createChart(key, chartElement, chartList[key].initialSeries, chartList[key].title, options);
                    resolve();
                });
            }));
        }
    }
    
    return Promise.all(chartPromises);
}

// Fetch data and create charts for a tab (optimized with parallel requests)
async function fetchAndCreateCharts(tabKey) {
    const fetchPromises = [
        fetchData(tabKey, '{{ .PullFromDevice }}')
    ];
    
    {{- if .SnowEnabled }}
    fetchPromises.push(fetchData(tabKey, '{{ .SnowDevice }}'));
    {{- end }}
    
    try {
        const results = await Promise.all(fetchPromises);
        const [data, snowData] = results;
        
        if (!data) return;
        
        processData(data, chartList);
        await createCharts(tabKey, chartList);
        
    } catch (error) {
        if (debug) console.error('Error fetching and creating charts:', error);
    }
}

// Generic chart creation function (exactly like original)
function createChart(chartName, targetDiv, data, title, options = {}) {
    const { yAxisTitle, chartType = 'spline', tooltipFormat, additionalSeries = [] } = options;
    const config = {
        chart: {
            type: chartType,
            backgroundColor: '#1a1a1a',
            style: { 
                fontFamily: 'Roboto, sans-serif',
                color: '#ffffff'
            },
            events: { load: () => markAsRendered(chartName) }
        },
        title: { 
            text: title,
            style: { color: '#ffffff' }
        },
        credits: { enabled: false },
        legend: { 
            enabled: additionalSeries.length > 0,
            itemStyle: { color: '#ffffff' }
        },
        xAxis: {
            type: 'datetime',
            dateTimeLabelFormats: { hour: '%l %p', minute: '%I:%M %p' },
            lineColor: '#404040',
            tickColor: '#404040',
            labels: { style: { color: '#ffffff' } }
        },
        yAxis: chartType === 'vector' ? { visible: false } : { 
            title: { 
                text: yAxisTitle,
                style: { color: '#ffffff' }
            },
            gridLineColor: '#404040',
            labels: { style: { color: '#ffffff' } }
        },
        time: { useUTC: false },
        tooltip: {
            backgroundColor: '#2a2a2a',
            borderColor: '#404040',
            style: { color: '#ffffff' },
            ...(tooltipFormat || {})
        },
        series: [
            {
                name: title,
                data,
                color: '#ffaa00', // Orange
                marker: {
                    enabled: false,
                    states: {
                        hover: {
                            enabled: true,
                            radius: 3
                        }
                    }
                }
            },
            ...additionalSeries
        ]
    };
    return Highcharts.chart(targetDiv, config);
}

// Mark a chart as rendered
async function markAsRendered(chartName) {
    chartList[chartName].rendered = true;
}

// Clear all charts
function clearCharts() {
    for (let key in chartList) {
        if (chartList[key].chart && chartList[key].chart.destroy) {
            chartList[key].chart.destroy();
            chartList[key].chart = null;
            chartList[key].rendered = false;
        }
    }
}

function refreshLiveData() {
    fetch('/latest')
        .then(response => response.json())
        .then(data => {
            if (data) {
                updateLiveReadings(data);
                updateLiveIndicator();
            }
        })
        .catch(error => {
            if (debug) console.error('Error fetching live data:', error);
            updateLiveIndicator(false);
        });
}

function updateLiveReadings(data) {
    // Temperature & Atmospheric
    updateElement('temperature', formatTemperatureValue(data.otemp));
    
    // Calculate feels-like temperature with debugging
    let feelsLike = data.heatidx || data.windch || data.otemp;
    if (debug) {
        console.log('Feels-like debug:', {
            heatidx: data.heatidx,
            windch: data.windch,
            otemp: data.otemp,
            calculated: feelsLike
        });
    }
    updateElement('feels-like', formatTemperatureValue(feelsLike));
    
    updateElement('humidity', `${data.ohum ? parseFloat(data.ohum).toFixed(1) : '--'}`);
    updateElement('dew-point', formatTemperatureValue(calculateDewPoint(data.otemp, data.ohum)));
    updateElement('barometer', `${data.bar ? parseFloat(data.bar).toFixed(2) : '--'}`);
    updateElement('solar', `${data.solarwatts ? parseFloat(data.solarwatts).toFixed(1) : '--'}`);
    
    // Sky conditions with debugging
    const skyCondition = calculateSkyConditions(data.solarwatts, data.potentialsolarwatts);
    if (debug) {
        console.log('Sky conditions calculation:', {
            solarwatts: data.solarwatts,
            potentialsolarwatts: data.potentialsolarwatts,
            result: skyCondition
        });
    }
    updateElement('sky-conditions', skyCondition);
  
    // Wind
    updateElement('wind-speed', `${data.winds ? Math.round(parseFloat(data.winds)) : '--'}`);
    updateElement('wind-gusts', `${data.windgust ? Math.round(parseFloat(data.windgust)) : '--'}`);
    updateElement('wind-direction', data.windcard || '--');
    updateElement('wind-degrees', `(${data.windd || '--'}°)`);
  
    // Update windrose - original implementation
    updateWindrose(data.windd, data.winds, data.windcard);
  
    // Precipitation
    updateElement('rain-today', `${data.dayrain !== null && data.dayrain !== undefined ? parseFloat(data.dayrain).toFixed(2) : '--'}`);
    updateElement('rain-rate', `${data.rainrate !== null && data.rainrate !== undefined ? parseFloat(data.rainrate).toFixed(2) : '--'}`);
    
    // Rainfall totals
    updateElement('rain-24hr', `${data.rainfall24h !== null && data.rainfall24h !== undefined ? parseFloat(data.rainfall24h).toFixed(2) : '--'}`);
    updateElement('rain-48hr', `${data.rainfall48h !== null && data.rainfall48h !== undefined ? parseFloat(data.rainfall48h).toFixed(2) : '--'}`);
    updateElement('rain-72hr', `${data.rainfall72h !== null && data.rainfall72h !== undefined ? parseFloat(data.rainfall72h).toFixed(2) : '--'}`);
    updateElement('rain-storm-total', `${data.rainfallstorm !== null && data.rainfallstorm !== undefined ? parseFloat(data.rainfallstorm).toFixed(2) : '--'}`);
  
          {{ if .SnowEnabled }}
      // Snow data - show 0.00 for nil/null/0 values
      updateElement('snow-depth', `${(data.snowdepth !== null && data.snowdepth !== undefined) ? parseFloat(data.snowdepth).toFixed(2) : '0.00'}`);
      updateElement('snow-24hr', `${(data.snowlast24 !== null && data.snowlast24 !== undefined) ? parseFloat(data.snowlast24).toFixed(2) : '0.00'}`);
      updateElement('snow-72hr', `${(data.snowlast72 !== null && data.snowlast72 !== undefined) ? parseFloat(data.snowlast72).toFixed(2) : '0.00'}`);
      updateElement('snow-storm-total', `${(data.snowstorm !== null && data.snowstorm !== undefined) ? parseFloat(data.snowstorm).toFixed(2) : '0.00'}`);
      // Use server-calculated snowfall rate if available, otherwise calculate manually
      let accumulationRate = '0.00';
      if (data.snowfallrate !== undefined && data.snowfallrate !== null && data.snowfallrate > 0) {
        accumulationRate = parseFloat(data.snowfallrate).toFixed(3);
      } else if (data.snowlast24 && data.snowlast24 > 0) {
        // Fallback: calculate rate from 24-hour total
        accumulationRate = (data.snowlast24 / 24).toFixed(3);
      }
      updateElement('snow-accumulation-rate', accumulationRate);
      {{ end }}
  
    // Station Status
    updateElement('battery', `${data.stationbatteryvoltage ? parseFloat(data.stationbatteryvoltage).toFixed(2) : '--'}`);
    updateElement('battery-status', getBatteryStatus(data.stationbatteryvoltage));
}

function updateElement(id, value) {
    const element = document.getElementById(id);
    if (element) {
        element.textContent = value;
        if (debug && id === 'feels-like') {
            console.log('Updated feels-like element:', { id, value, element });
        }
    } else {
        if (debug) {
            console.warn('Element not found:', id);
        }
    }
}

function formatTemperature(temp) {
    return temp != null ? `${Math.round(parseFloat(temp))}°F` : '--°F';
}

function formatTemperatureValue(temp) {
    return temp != null ? `${Math.round(parseFloat(temp))}` : '--';
}

function calculateDewPoint(temp, humidity) {
    if (!temp || !humidity) return null;
    const t = parseFloat(temp);
    const h = parseFloat(humidity);
    const a = 17.27;
    const b = 237.7;
    const alpha = ((a * t) / (b + t)) + Math.log(h / 100.0);
    return (b * alpha) / (a - alpha);
}

function calculateSolarPercent(current, max) {
    if (!current || !max || parseFloat(max) === 0) return '--';
    return Math.round((parseFloat(current) / parseFloat(max)) * 100);
}

function calculateSkyConditions(current, max) {
    // Handle null/undefined values
    if (current === null || current === undefined || max === null || max === undefined) {
        return '--';
    }
    
    const currentValue = parseFloat(current);
    const maxValue = parseFloat(max);
    
    // Handle NaN values
    if (isNaN(currentValue) || isNaN(maxValue)) {
        return '--';
    }
    
    // If potential solar is very low, it's night
    if (maxValue < 10) return 'Night';
    
    // Handle zero max value to avoid division by zero
    if (maxValue === 0) return 'Night';
    
    // Calculate percentage
    const percentage = (currentValue / maxValue) * 100;
    
    if (debug) {
        console.log('Sky conditions debug:', {
            current: currentValue,
            max: maxValue,
            percentage: percentage
        });
    }
    
    if (percentage >= 80) return 'Sunny';
    if (percentage >= 40) return 'Partly Cloudy';
    return 'Cloudy';
}

function getBatteryStatus(voltage) {
    if (!voltage) return '--';
    const v = parseFloat(voltage);
    if (v >= 12.6) return 'Good';
    if (v >= 12.0) return 'Fair';
    return 'Low';
}

function updateWindrose(direction, speed, cardinalDir) {
    // Update the windrose circle rotation (original implementation)
    const windDirElement = document.getElementById('rdg-winddir');
    if (windDirElement && direction != null) {
        windDirElement.style.transform = `rotate(${direction}deg)`;
    }
    
    // Update the cardinal direction display
    const cardinalElement = document.getElementById('rdg-winddir-cardinal');
    if (cardinalElement) {
        cardinalElement.textContent = cardinalDir || '---';
    }
    
    // Update the wind speed display in the windrose
    const speedElement = document.getElementById('rdg-windspeed');
    if (speedElement) {
        speedElement.textContent = speed ? Math.round(parseFloat(speed)) : '--';
    }
}

function updateLiveIndicator(isLive = true) {
    const indicator = document.getElementById('live-indicator');
    const update = document.getElementById('last-update');
  
    if (indicator) {
        indicator.style.color = isLive ? '#ffffff' : '#888';
    }
  
    if (update) {
        update.textContent = isLive ? 'Updated just now' : 'Update failed';
    }
}

// Error handling
window.addEventListener('error', function(e) {
    if (debug) {
        console.error('Weather dashboard error:', e.error);
    }
});

// Visibility change handling - refresh when page becomes visible
document.addEventListener('visibilitychange', function() {
    if (!document.hidden) {
        refreshLiveData();
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (liveDataTimer) {
        clearInterval(liveDataTimer);
    }
    clearCharts();
}); 