// Weather Dashboard Application Module
// This is the main application that uses all the refactored modules

const WeatherApp = (function() {
    'use strict';
    
    // Configuration from template
    const config = {
        pullFromDevice: '{{ .PullFromDevice }}',
        stationID: {{ .StationID }},
        snowEnabled: {{ .SnowEnabled }},
        snowDevice: '{{ .SnowDevice }}',
        airQualityEnabled: {{ .AirQualityEnabled }},
        airQualityDevice: '{{ .AirQualityDevice }}',
        airQualityDeviceID: {{ .AirQualityDeviceID }},
        stationName: '{{ .StationName }}',
        aerisWeatherEnabled: {{ .AerisWeatherEnabled }},
        debug: new URLSearchParams(window.location.search).get('debug') === '1'
    };
    
    // Application state
    let state = {
        currentRange: '24h',
        currentForecastType: 'week',
        secondsSinceLastUpdate: 0,
        liveDataTimer: null,
        updateTimerInterval: null,
        chartRefreshTimer: null
    };
    
    // Constants
    const INTERVALS = {
        LIVE_DATA: 3500,
        CHART_REFRESH: 300000,
        FORECAST_REFRESH: 4 * 60 * 60 * 1000
    };
    
    const CHART_RANGES = {
        '24h': 24,
        '72h': 72,
        '7d': 168,
        '30d': 744,
        '1y': 8760
    };
    
    // Initialize the application
    const init = () => {
        if (config.debug) console.log('Initializing Weather App with config:', config);
        
        // Set up event listeners
        setupEventListeners();
        
        // Initialize air quality tooltips if air quality is enabled
        if (config.airQualityEnabled) {
            WeatherDOM.initializeTooltips();
        }
        
        // Start timers
        startTimers();
        
        // Load initial data
        loadInitialData();
        
        // Set up cleanup handlers
        setupCleanupHandlers();
    };
    
    // Set up event listeners
    const setupEventListeners = () => {
        // Chart tab listeners
        document.querySelectorAll('.chart-tab').forEach(tab => {
            tab.addEventListener('click', handleChartTabClick);
        });
        
        // Forecast tab listeners (only if Aeris Weather is enabled)
        if (config.aerisWeatherEnabled) {
            document.querySelectorAll('.forecast-tab').forEach(tab => {
                tab.addEventListener('click', handleForecastTabClick);
            });
        }
    };
    
    // Handle chart tab clicks
    const handleChartTabClick = (event) => {
        const range = event.currentTarget.dataset.range;
        if (range && range !== state.currentRange) {
            switchChartRange(range);
        }
    };
    
    // Handle forecast tab clicks
    const handleForecastTabClick = (event) => {
        const forecastType = event.currentTarget.dataset.forecastType;
        if (forecastType && forecastType !== state.currentForecastType) {
            switchForecastType(forecastType);
        }
    };
    
    // Switch chart range
    const switchChartRange = async (range) => {
        state.currentRange = range;
        WeatherDOM.switchChartRange(range);
        
        // Clear existing charts
        WeatherCharts.destroyAllCharts();
        
        // Load new charts
        await loadChartsForRange(range);
    };
    
    // Switch forecast type
    const switchForecastType = (type) => {
        state.currentForecastType = type;
        WeatherDOM.switchForecastType(type);
    };
    
    // Start timers
    const startTimers = () => {
        // Live data refresh timer
        state.liveDataTimer = setInterval(refreshLiveData, INTERVALS.LIVE_DATA);

        // Update timer (for "last updated X seconds ago")
        state.updateTimerInterval = setInterval(() => {
            state.secondsSinceLastUpdate++;
            WeatherDOM.updateLiveIndicator(true, state.secondsSinceLastUpdate);
        }, 1000);
    };

    // Load almanac data
    const loadAlmanac = async () => {
        try {
            const url = `/almanac?station=${config.pullFromDevice}`;
            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`Failed to fetch almanac data: ${response.statusText}`);
            }

            const almanac = await response.json();
            updateAlmanacDisplay(almanac);
        } catch (error) {
            if (config.debug) console.error('Error loading almanac data:', error);
        }
    };

    // Update almanac display
    const updateAlmanacDisplay = (almanac) => {
        // Helper function to format timestamp
        const formatTimestamp = (timestamp) => {
            if (!timestamp) return '--';
            const date = new Date(timestamp);
            return date.toLocaleString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        };

        // Helper function to get wind direction from degrees
        const getWindDirection = (degrees) => {
            if (degrees === null || degrees === undefined) return '--';
            const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
            const index = Math.round(degrees / 22.5) % 16;
            return `${directions[index]} (${Math.round(degrees)}Â°)`;
        };

        // Helper function to update metric
        const updateMetric = (valueId, timeId, record, precision = 1) => {
            const valueEl = document.getElementById(valueId);
            const timeEl = document.getElementById(timeId);

            if (valueEl && record) {
                valueEl.textContent = record.value.toFixed(precision);
            }
            if (timeEl && record) {
                timeEl.textContent = formatTimestamp(record.timestamp);
            }
        };

        // Update basic metrics
        updateMetric('almanac-high-temp', 'almanac-high-temp-time', almanac.high_temp);
        updateMetric('almanac-low-temp', 'almanac-low-temp-time', almanac.low_temp);
        updateMetric('almanac-max-rain-hour', 'almanac-max-rain-hour-time', almanac.max_rain_hour, 2);
        updateMetric('almanac-max-rain-day', 'almanac-max-rain-day-time', almanac.max_rain_day, 2);
        updateMetric('almanac-low-baro', 'almanac-low-baro-time', almanac.low_barometer, 2);
        updateMetric('almanac-high-solar', 'almanac-high-solar-time', almanac.high_solar, 0);
        updateMetric('almanac-low-humidity', 'almanac-low-humidity-time', almanac.low_humidity, 0);

        // Update wind with direction
        if (almanac.high_wind_speed) {
            const windValueEl = document.getElementById('almanac-high-wind');
            const windDirEl = document.getElementById('almanac-high-wind-dir');
            const windTimeEl = document.getElementById('almanac-high-wind-time');

            if (windValueEl) windValueEl.textContent = almanac.high_wind_speed.value.toFixed(1);
            if (windDirEl && almanac.high_wind_speed.wind_dir !== undefined) {
                windDirEl.textContent = `from ${getWindDirection(almanac.high_wind_speed.wind_dir)}`;
            }
            if (windTimeEl) windTimeEl.textContent = formatTimestamp(almanac.high_wind_speed.timestamp);
        }

        // Update snow metrics if enabled
        if (config.snowEnabled) {
            updateMetric('almanac-deepest-snow', 'almanac-deepest-snow-time', almanac.deepest_snow, 1);
            updateMetric('almanac-max-snow-hour', 'almanac-max-snow-hour-time', almanac.max_snow_hour, 1);
            updateMetric('almanac-max-snow-day', 'almanac-max-snow-day-time', almanac.max_snow_day, 1);
        }

        // Update air quality metrics if enabled
        if (config.airQualityEnabled) {
            updateMetric('almanac-high-pm25', 'almanac-high-pm25-time', almanac.high_pm25, 1);
            updateMetric('almanac-high-pm10', 'almanac-high-pm10-time', almanac.high_pm10_in, 1);
            updateMetric('almanac-high-co2', 'almanac-high-co2-time', almanac.high_co2, 0);
            updateMetric('almanac-high-aqi-pm25', 'almanac-high-aqi-pm25-time', almanac.high_aqi_pm25, 0);
            updateMetric('almanac-high-aqi-pm10', 'almanac-high-aqi-pm10-time', almanac.high_aqi_pm10, 0);
            updateMetric('almanac-high-aqi-pm25-in', 'almanac-high-aqi-pm25-in-time', almanac.high_aqi_pm25_in, 0);
        }
    };

    // Load initial data
    const loadInitialData = async () => {
        // Load all data in parallel for faster initial load
        const promises = [
            refreshLiveData(),
            loadChartsForRange(state.currentRange),
            loadAlmanac()
        ];

        // Add forecast promises if Aeris Weather is enabled
        if (config.aerisWeatherEnabled) {
            promises.push(refreshWeekForecast());
            promises.push(refreshDayForecast());
        }

        // Wait for all data to load in parallel
        await Promise.all(promises);
    };
    
    // Refresh live data
    const refreshLiveData = async () => {
        try {
            const { weather, snow, airQuality } = await WeatherDataService.fetchLiveData(
                config.snowEnabled, 
                config.airQualityEnabled,
                config.stationID,
                config.airQualityDeviceID
            );
            
            if (weather) {
                const processedWeather = WeatherDataService.processLiveWeatherData(weather);
                const processedSnow = config.snowEnabled ? 
                    WeatherDataService.processSnowData(snow) : null;
                
                WeatherDOM.updateLiveWeather(processedWeather, processedSnow);
                
                // Update air quality data if enabled and available
                if (config.airQualityEnabled && airQuality) {
                    WeatherDOM.updateAirQualityData(airQuality);
                }
                
                state.secondsSinceLastUpdate = 0;
                WeatherDOM.updateLiveIndicator(true, 0);
            } else {
                WeatherDOM.updateLiveIndicator(false);
            }
        } catch (error) {
            if (config.debug) console.error('Error refreshing live data:', error);
            WeatherDOM.updateLiveIndicator(false);
        }
    };
    
    // Load charts for a specific range
    const loadChartsForRange = async (range) => {
        const hours = CHART_RANGES[range];
        
        try {
            const { mainData, snowData, airQualityData } = await WeatherDataService.fetchChartData(hours, config);
            
            if (!mainData) return;
            
            // Create charts for each metric
            const chartMetrics = Object.keys(WeatherCharts.chartTypeConfigs);
            
            for (const metric of chartMetrics) {
                // Skip snow chart if not enabled
                if (metric === 'snowdepth' && !config.snowEnabled) continue;
                
                // Skip air quality charts if not enabled
                if ((metric === 'pm25' || metric === 'pm10' || metric === 'co2' || metric === 'tvocindex' || metric === 'noxindex') && !config.airQualityEnabled) continue;
                
                const elementId = metric + 'Chart' + range;
                const element = WeatherDOM.getCachedElement(elementId);
                
                if (element) {
                    // Determine which data source to use
                    let dataSource = mainData;
                    if (metric === 'snowdepth') {
                        dataSource = snowData || mainData;
                    } else if (metric === 'pm25' || metric === 'pm10' || metric === 'co2' || metric === 'tvocindex' || metric === 'noxindex') {
                        dataSource = airQualityData;
                        if (!dataSource) continue;
                    }
                    
                    // Process data for this chart type
                    const chartData = WeatherCharts.processChartData(
                        dataSource, 
                        metric, 
                        { snowData: snowData, airQualityData: airQualityData }
                    );
                    
                    // Get additional series if any
                    const additionalSeries = WeatherCharts.getAdditionalSeriesData(dataSource, metric);
                    
                    // Create the chart
                    const chartConfig = WeatherCharts.getChartConfig(metric);
                    const options = {
                        ...chartConfig,
                        additionalSeries: additionalSeries
                    };
                    
                    // Create chart with proper title
                    const title = metric.charAt(0).toUpperCase() + metric.slice(1).replace(/([A-Z])/g, ' $1');
                    WeatherCharts.createChart(metric, element, chartData, title, options);
                }
            }
        } catch (error) {
            if (config.debug) console.error('Error loading charts:', error);
        }
    };
    
    // Refresh week forecast
    const refreshWeekForecast = async () => {
        try {
            const data = await WeatherDataService.fetchForecast(240, config.stationID);
            if (!data) {
                setTimeout(refreshWeekForecast, 60000);
                return;
            }
            
            const processed = WeatherDataService.processForecastData(data, 'week');
            const lastUpdated = WeatherUtils.formatLastUpdated(data.lastUpdated);
            
            WeatherDOM.updateWeekForecast(processed, lastUpdated);
            
            // Schedule next refresh
            setTimeout(refreshWeekForecast, INTERVALS.FORECAST_REFRESH);
        } catch (error) {
            if (config.debug) console.error('Error refreshing week forecast:', error);
            setTimeout(refreshWeekForecast, 60000);
        }
    };
    
    // Refresh day forecast
    const refreshDayForecast = async () => {
        try {
            const data = await WeatherDataService.fetchForecast(24, config.stationID);
            if (!data) {
                setTimeout(refreshDayForecast, 60000);
                return;
            }
            
            const processed = WeatherDataService.processForecastData(data, 'day');
            const lastUpdated = WeatherUtils.formatLastUpdated(data.lastUpdated);
            
            // Calculate temperature scaling for vertical positioning
            const temps = processed.map(h => h.temp);
            const minTemp = Math.min(...temps);
            const maxTemp = Math.max(...temps);
            const tempSpread = maxTemp - minTemp;
            const isMobile = window.innerWidth <= 700;
            const tempSpreadPixels = isMobile ? 25 : 80;
            
            const temperatureScaling = tempSpread > 0 ? {
                pixelsPerDegree: tempSpreadPixels / tempSpread,
                highTemp: maxTemp
            } : null;
            
            WeatherDOM.updateDayForecast(processed, lastUpdated, temperatureScaling);
            
            // Schedule next refresh
            setTimeout(refreshDayForecast, INTERVALS.FORECAST_REFRESH);
        } catch (error) {
            if (config.debug) console.error('Error refreshing day forecast:', error);
            setTimeout(refreshDayForecast, 60000);
        }
    };
    
    // Setup cleanup handlers
    const setupCleanupHandlers = () => {
        // Cleanup on page unload
        window.addEventListener('beforeunload', cleanup);
        
        // Refresh when page becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                refreshLiveData();
            }
        });
    };
    
    // Cleanup function
    const cleanup = () => {
        if (state.liveDataTimer) {
            clearInterval(state.liveDataTimer);
        }
        if (state.updateTimerInterval) {
            clearInterval(state.updateTimerInterval);
        }
        if (state.chartRefreshTimer) {
            clearInterval(state.chartRefreshTimer);
        }

        WeatherCharts.destroyAllCharts();
        WeatherDOM.clearCache();
    };

    // Global function for theme refresh
    window.refreshChartsForTheme = () => {
        WeatherCharts.destroyAllCharts();
        loadChartsForRange(state.currentRange);
    };

    // Public API
    return {
        init,
        config,
        refreshLiveData,
        loadAlmanac,
        cleanup
    };
})();

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    WeatherApp.init();
});