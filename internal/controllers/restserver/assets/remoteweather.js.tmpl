// Global chart objects
let humidityChart, temperatureChart, barometerChart, snowdepthChart, windspeedChart, 
    winddirectionChart, rainfallChart, solarwattsChart, voltageChart;

// Timer variables
let dataRefresherTimer, windDataRefresherTimer;
let secondsSinceForecastRefreshed, forecastLastRefreshedElement;

// Constants for maintainability
const MAX_POINTS = 20;
const DATA_REFRESH_INTERVAL = 300000; // 5 minutes
const WIND_DATA_REFRESH_INTERVAL = 1800000; // 30 minutes
const LIVE_READINGS_REFRESH_INTERVAL = 3000; // 3 seconds
const FORECAST_REFRESH_INTERVAL = 1000 * 60 * 60 * 4; // 4 hours

// Debug flag based on URL parameter
const debug = new URLSearchParams(window.location.search).get('debug') === '1';

// DOM element cache for performance
const domCache = new Map();

// Optimized DOM element accessor with caching
function getCachedElement(elementId) {
    if (!domCache.has(elementId)) {
        const element = document.getElementById(elementId);
        if (element) {
            domCache.set(elementId, element);
        } else if (debug) {
            console.warn(`Element not found: ${elementId}`);
        }
    }
    return domCache.get(elementId);
}

// Forecast tab configuration
let forecastTabList = {
    "week": {
        "periodDivPrefix": "week",
        "elementIdVal": "forecast-tab-week",
        "spanHours": 168
    }
};

// Chart tab configuration
let chartTabList = {
    "day": {
        "graphDivSuffix": "24Hour",
        "elementIdVal": "tab-day",
        "spanHours": 24
    },
    "threedays": {
        "graphDivSuffix": "72Hours",
        "elementIdVal": "tab-threedays",
        "spanHours": 72
    },
    "week": {
        "graphDivSuffix": "Week",
        "elementIdVal": "tab-week",
        "spanHours": 168
    },
    "month": {
        "graphDivSuffix": "Month",
        "elementIdVal": "tab-month",
        "spanHours": 744
    },
    "year": {
        "graphDivSuffix": "Year",
        "elementIdVal": "tab-year",
        "spanHours": 8928
    }
};

// Chart configuration object
let chartList = {
    "temperature": {
        "chart": temperatureChart,
        "divId": "temperatureChart",
        "title": "Outside Temperature",
        "yAxisLabel": "Degrees F",
        "chartType": "spline",
        "pointName": "outsideTempPoint",
        "initialSeries": [],
        "rendered": false
    },
    "humidity": {
        "chart": humidityChart,
        "divId": "humidityChart",
        "title": "Humidity",
        "yAxisLabel": "Percent",
        "chartType": "spline",
        "pointName": "outsideHumidityPoint",
        "initialSeries": [],
        "rendered": false
    },
    {{- if .SnowEnabled }}
    "snowdepth": {
        "chart": snowdepthChart,
        "divId": "snowdepthChart",
        "title": "Snow Depth",
        "yAxisLabel": "inches",
        "chartType": "spline",
        "pointName": "snowdepthPoint",
        "initialSeries": [],
        "rendered": false
    },
    {{- end }}
    "barometer": {
        "chart": barometerChart,
        "divId": "barometerChart",
        "title": "Barometer",
        "yAxisLabel": "inches Hg",
        "chartType": "spline",
        "pointName": "barometerPoint",
        "initialSeries": [],
        "rendered": false
    },
    "windspeed": {
        "chart": windspeedChart,
        "divId": "windspeedChart",
        "title": "Wind Speed",
        "yAxisLabel": "MPH",
        "chartType": "spline",
        "pointName": "windSpeedPoint",
        "initialSeries": [],
        "rendered": false
    },
    "winddirection": {
        "chart": winddirectionChart,
        "divId": "winddirectionChart",
        "title": "Wind Direction",
        "yAxisLabel": "",
        "chartType": "vector",
        "pointName": "windDirectionVectorPoint",
        "initialSeries": [],
        "rendered": false
    },
    "rainfall": {
        "chart": rainfallChart,
        "divId": "rainfallChart",
        "title": "Rainfall",
        "yAxisLabel": "Inches",
        "chartType": "column",
        "pointName": "rainfallPoint",
        "initialSeries": [],
        "rendered": false
    },
    "solarwatts": {
        "chart": solarwattsChart,
        "divId": "solarwattsChart",
        "title": "Observed Solar Radiation",
        "yAxisLabel": "Watts/m²",
        "chartType": "spline",
        "pointName": "solarWattsPoint",
        "initialSeries": [],
        "rendered": false,
        "additionalSeries": [{
            name: "Maximum Potential Solar Radiation",
            data: [],
            color: '#FFA500' // Orange
        }]
    },
    "voltage": {
        "chart": voltageChart,
        "divId": "voltageChart",
        "title": "Station Battery Voltage",
        "yAxisLabel": "Volts",
        "chartType": "spline",
        "pointName": "voltagePoint",
        "initialSeries": [],
        "rendered": false
    }
};

// Initialize on DOM content loaded
document.addEventListener('DOMContentLoaded', function () {
    forecastLastRefreshedElement = getCachedElement('observations-last-updated');
    
    // Start all initial data fetching in parallel for faster loading
    Promise.all([
        fetchAndCreateCharts("day"),
        refreshLiveReadings(),
        refreshWeekForecastData(),
        refreshDayForecastData()
    ]).catch(error => {
        if (debug) console.error('Error during initial data loading:', error);
    });
    
    // Set up event listeners for chart tabs
    for (let key in chartTabList) {
        const element = getCachedElement(chartTabList[key].elementIdVal);
        if (element) {
            element.addEventListener("click", function () {
                clearCharts();
                fetchAndCreateCharts(key);
            });
        }
    }
    
    setInterval(incrementObservationTimer, 1000);
});

// Increment timer for last refreshed display
function incrementObservationTimer() {
    secondsSinceForecastRefreshed++;
    if (forecastLastRefreshedElement) {
        forecastLastRefreshedElement.innerHTML = "Last refreshed " + secondsSinceForecastRefreshed + "s ago";
    }
}

// Clear charts and timers
function clearCharts() {
    clearTimeout(dataRefresherTimer);
    clearTimeout(windDataRefresherTimer);
    for (let key in chartList) {
        chartList[key].chart = {};
        chartList[key].initialSeries = [];
        if (chartList[key].additionalSeries) {
            chartList[key].additionalSeries.forEach(series => series.data = []);
        }
        chartList[key].rendered = false;
    }
}

// Optimized fetch with error handling and timeout
async function fetchWithTimeout(url, timeout = 10000) {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
        return response.json();
    } catch (error) {
        clearTimeout(timeoutId);
        if (debug) console.error(`Failed to fetch ${url}:`, error);
        return null;
    }
}

// Fetch data for a given tab and station
async function fetchData(tabKey, station) {
    return fetchWithTimeout(`/span/${chartTabList[tabKey].spanHours}h?station=${station}`);
}

// Process fetched data into chart series (optimized)
function processData(data, chartList) {
    if (!data || !Array.isArray(data)) return;
    
    const modVal = Math.max(1, Math.floor(data.length / 50));
    const dataLength = data.length;
    
    // Pre-allocate arrays for better performance
    chartList.temperature.initialSeries = new Array(dataLength);
    chartList.humidity.initialSeries = new Array(dataLength);
    chartList.barometer.initialSeries = new Array(dataLength);
    chartList.windspeed.initialSeries = new Array(dataLength);
    chartList.rainfall.initialSeries = new Array(dataLength);
    chartList.voltage.initialSeries = new Array(dataLength);
    chartList.solarwatts.initialSeries = new Array(dataLength);
    
    if (chartList.solarwatts.additionalSeries) {
        chartList.solarwatts.additionalSeries[0].data = new Array(dataLength);
    }
    
    let windDirectionIndex = 0;
    chartList.winddirection.initialSeries = [];
    
    // Single loop to process all data
    for (let i = 0; i < dataLength; i++) {
        const item = data[i];
        const ts = item.ts;
        
        chartList.temperature.initialSeries[i] = [ts, item.otemp];
        chartList.humidity.initialSeries[i] = [ts, item.outhumidity];
        chartList.barometer.initialSeries[i] = [ts, item.bar];
        chartList.windspeed.initialSeries[i] = [ts, item.winds];
        chartList.rainfall.initialSeries[i] = [ts, item.period_rain];
        chartList.voltage.initialSeries[i] = [ts, item.stationbatteryvoltage];
        chartList.solarwatts.initialSeries[i] = [ts, item.solarwatts];
        
        if (chartList.solarwatts.additionalSeries) {
            chartList.solarwatts.additionalSeries[0].data[i] = [ts, item.potentialsolarwatts];
        }
        
        if (i % modVal === 0 || dataLength < 50) {
            chartList.winddirection.initialSeries.push([ts, 5, item.winds, item.windd]);
        }
    }
}

// Create charts for all metrics (parallelized)
function createCharts(tabKey, chartList) {
    const chartPromises = [];
    
    for (let key in chartList) {
        const chartElement = getCachedElement(`${chartList[key].divId}${chartTabList[tabKey].graphDivSuffix}`);
        if (chartElement) {
            const options = {
                yAxisTitle: chartList[key].yAxisLabel,
                chartType: chartList[key].chartType,
                tooltipFormat: chartList[key].chartType === 'vector' ? {
                    pointFormat: '{date point.x}<br/>Speed: <b>{point.length:.1f} MPH</b><br/>Direction: <b>{point.direction:.0f}\u00B0</b>'
                } : { valueDecimals: 2 },
                ...(chartList[key].additionalSeries ? { additionalSeries: chartList[key].additionalSeries } : {})
            };
            
            // Create charts in parallel using requestAnimationFrame for better performance
            chartPromises.push(new Promise(resolve => {
                requestAnimationFrame(() => {
                    chartList[key].chart = createChart(key, chartElement, chartList[key].initialSeries, chartList[key].title, options);
                    resolve();
                });
            }));
        }
    }
    
    return Promise.all(chartPromises);
}

// Fetch data and create charts for a tab (optimized with parallel requests)
async function fetchAndCreateCharts(tabKey) {
    const fetchPromises = [
        fetchData(tabKey, '{{ .PullFromDevice }}')
    ];
    
    {{- if .SnowEnabled }}
    fetchPromises.push(fetchData(tabKey, '{{ .SnowDevice }}'));
    {{- end }}
    
    try {
        const results = await Promise.all(fetchPromises);
        const [data, snowData] = results;
        
        if (!data) return;
        
        processData(data, chartList);
        await createCharts(tabKey, chartList);
        
        {{- if .SnowEnabled }}
        if (snowData) {
            snowData.forEach(item => {
                chartList.snowdepth.initialSeries.push([item.ts, item.snowdepth]);
            });
            const snowChartElement = getCachedElement(`${chartList.snowdepth.divId}${chartTabList[tabKey].graphDivSuffix}`);
            if (snowChartElement) {
                chartList.snowdepth.chart = createChart('snowdepth', snowChartElement, chartList.snowdepth.initialSeries, chartList.snowdepth.title, {
                    yAxisTitle: chartList.snowdepth.yAxisLabel,
                    chartType: chartList.snowdepth.chartType,
                    tooltipFormat: { valueDecimals: 2 }
                });
            }
        }
        {{- end }}
        
        // Start refresh cycles
        refreshData();
        refreshWindDirectionData();
    } catch (error) {
        if (debug) console.error('Error fetching and creating charts:', error);
    }
}

// Fetch the latest general weather data
async function fetchLatestData(station) {
    return fetchWithTimeout(`/latest?station=${station}`);
}

{{- if .SnowEnabled }}
// Fetch the latest snow data
async function fetchSnowData(station) {
    return fetchWithTimeout(`/snow?station=${station}`);
}
{{- end }}

// Update a chart's series with a new point
function updateChartSeries(chart, point, maxPoints = MAX_POINTS) {
    if (!chart.rendered) return;
    if (chart.chart.series.length > 1) {
        chart.chart.series.forEach((series, index) => {
            const shift = series.data.length > maxPoints;
            series.addPoint(point[index], true, shift);
        });
    } else {
        const series = chart.chart.series[0];
        const shift = series.data.length > maxPoints;
        series.addPoint(point, true, shift);
    }
}

// Refresh chart data periodically
async function refreshData() {
    clearTimeout(dataRefresherTimer);
    const data = await fetchLatestData('{{ .PullFromDevice }}');
    if (!data) return;
    const points = {
        outsideTempPoint: [data.ts, data.otemp],
        outsideHumidityPoint: [data.ts, data.outhumidity],
        barometerPoint: [data.ts, data.bar],
        windSpeedPoint: [data.ts, data.winds],
        voltagePoint: [data.ts, data.stationbatteryvoltage],
        rainfallPoint: [data.ts, data.dayrain],
        solarWattsPoint: [
            [data.ts, data.solarwatts],
            [data.ts, data.potentialsolarwatts]
        ]
    };
    for (let key in chartList) {
        if (key !== 'winddirection' && chartList[key].rendered) {
            updateChartSeries(chartList[key], points[chartList[key].pointName]);
        }
    }
    {{- if .SnowEnabled }}
    const snowData = await fetchSnowData('{{ .SnowDevice }}');
    if (snowData) {
        const snowPoint = [snowData.ts, snowData.snowdepth];
        updateChartSeries(chartList.snowdepth, snowPoint);
    }
    {{- end }}
    dataRefresherTimer = setTimeout(refreshData, DATA_REFRESH_INTERVAL);
}

// Refresh wind direction data periodically
async function refreshWindDirectionData() {
    clearTimeout(windDataRefresherTimer);
    const data = await fetchLatestData('{{ .PullFromDevice }}');
    if (data && chartList.winddirection.rendered) {
        const windDirectionPoint = [data.ts, 5, data.winds, data.windd];
        updateChartSeries(chartList.winddirection, windDirectionPoint);
    }
    windDataRefresherTimer = setTimeout(refreshWindDirectionData, WIND_DATA_REFRESH_INTERVAL);
}

// Optimized DOM update with caching and change detection
function updateIfChanged(elementId, newValue) {
    const element = getCachedElement(elementId);
    if (element && element.innerHTML !== newValue) {
        element.innerHTML = newValue;
    }
}

// Refresh live readings periodically (optimized with parallel requests)
async function refreshLiveReadings() {
    try {
        const fetchPromises = [fetchLatestData('{{ .PullFromDevice }}')];
        
        {{- if .SnowEnabled }}
        fetchPromises.push(fetchSnowData('{{ .SnowDevice }}'));
        {{- end }}
        
        const results = await Promise.all(fetchPromises);
        const [data, snowData] = results;
        
        if (data) {
            // Batch DOM updates for better performance
            requestAnimationFrame(() => {
                updateIfChanged('rdg-temperature', data.otemp.toFixed(2) + '°');
                updateIfChanged('rdg-humidity', data.outhumidity.toFixed(0));
                updateIfChanged('rdg-barometer', data.bar.toFixed(2));
                updateIfChanged('rdg-windspeed', data.winds.toFixed(0));
                updateIfChanged('rdg-winddir-cardinal', data.windcard);
                updateIfChanged('rdg-combined-windspeed', data.winds.toFixed(0));
                updateIfChanged('rdg-combined-cardinal', data.windcard);
                updateIfChanged('rdg-rainfall', data.dayrain.toFixed(2));
                
                const windDirElement = getCachedElement('rdg-winddir');
                if (windDirElement) windDirElement.style.transform = `rotate(${data.windd}deg)`;
            });
        } else if (debug) {
            console.warn('No data received from {{ .PullFromDevice }}');
        }

        {{- if .SnowEnabled }}
        if (snowData) {
            if (debug) console.log('Snow data received:', snowData);
            requestAnimationFrame(() => {
                updateIfChanged('rdg-snow-depth', snowData.snowdepth?.toFixed(2) ?? 'N/A');
                updateIfChanged('rdg-snow-since-midnight', snowData.snowtoday?.toFixed(2) ?? 'N/A');
                updateIfChanged('rdg-snow-last-24h', snowData.snowlast24?.toFixed(2) ?? 'N/A');
                updateIfChanged('rdg-snow-last-72h', snowData.snowlast72?.toFixed(2) ?? 'N/A');
                updateIfChanged('rdg-snow-season', snowData.snowseason?.toFixed(2) ?? 'N/A');
                updateIfChanged('rdg-snow-storm', snowData.snowstorm?.toFixed(2) ?? 'N/A');
            });
        } else if (debug) {
            console.warn('No snow data received from {{ .SnowDevice }}');
        }
        {{- end }}

        secondsSinceForecastRefreshed = 0;
    } catch (error) {
        if (debug) console.error('Error refreshing live readings:', error);
    }
    
    setTimeout(refreshLiveReadings, LIVE_READINGS_REFRESH_INTERVAL);
}

// Refresh week forecast data
async function refreshWeekForecastData() {
    if (debug) console.log("Fetching week forecast data...");
    try {
        const data = await fetchWithTimeout('/forecast/168');
        if (!data) {
            setTimeout(refreshWeekForecastData, 60000);
            return;
        }
        
        if (debug) console.log("Week forecast data received:", data);

        const dayToDayName = {
            0: "Sunday", 1: "Monday", 2: "Tuesday", 3: "Wednesday",
            4: "Thursday", 5: "Friday", 6: "Saturday", 7: "Sunday"
        };

        // Batch DOM updates
        requestAnimationFrame(() => {
            let i = 0;
            for (const interval of data.data) {
                let intervalDate = new Date(interval.dateTimeISO);
                let dateLabel = i === 0 ? "Today" : dayToDayName[intervalDate.getDay()];
                
                updateIfChanged(`week-forecast-interval-${i}-title`, dateLabel);
                updateIfChanged(`week-forecast-interval-${i}-high-temp`, interval.maxTempF);
                updateIfChanged(`week-forecast-interval-${i}-low-temp`, interval.minTempF);
                updateIfChanged(`week-forecast-interval-${i}-icon`, interval.weatherIcon);
                updateIfChanged(`week-forecast-interval-${i}-weather`, interval.compactWeather);

                const snowRegex = /.*:.*:(S|SW|SI|RS|WM|BS)$/g;
                const snow = snowRegex.test(interval.weatherPrimaryCoded);
                const rainRegex = /.*:.*:(R|RW|T|TO|UP|ZR|L|BY|ZY|ZR)$/g;
                const rain = rainRegex.test(interval.weatherPrimaryCoded);

                if (snow) {
                    if (debug) console.log(`Week forecast interval ${i} - snow: `, interval.snowIN);
                    updateIfChanged(`week-forecast-interval-${i}-precip-icon`, "❄");
                    updateIfChanged(`week-forecast-interval-${i}-precip`, interval.snowIN + "\"");
                } else if (rain) {
                    if (debug) console.log(`Week forecast interval ${i} - rain: `, interval.precipIN);
                    updateIfChanged(`week-forecast-interval-${i}-precip-icon`, "⛆");
                    updateIfChanged(`week-forecast-interval-${i}-precip`, interval.precipIN + "\"");
                } else {
                    if (debug) console.log(`Week forecast interval ${i} - no precip`);
                    updateIfChanged(`week-forecast-interval-${i}-precip-icon`, "");
                    updateIfChanged(`week-forecast-interval-${i}-precip`, "");
                }
                i++;
            }

            const lastUpdated = moment(data.lastUpdated, "YYYY-MM-DD HH:mm:ss.SSSSSS-ZZ").format("h:mm A, DD MMM YYYY");
            updateIfChanged('forecast-week-last-updated', "Last Updated: " + lastUpdated);
        });

        setTimeout(refreshWeekForecastData, FORECAST_REFRESH_INTERVAL);
    } catch (error) {
        if (debug) console.error("Failed to fetch week forecast data:", error);
        setTimeout(refreshWeekForecastData, 60000); // Retry in 1 minute
    }
}

// Refresh day forecast data
async function refreshDayForecastData() {
    if (debug) console.log("Fetching day forecast data...");
    try {
        const data = await fetchWithTimeout('/forecast/24');
        if (!data) {
            setTimeout(refreshDayForecastData, 60000);
            return;
        }
        
        if (debug) console.log("Day forecast data received:", data);

        // Pre-calculate temperature scaling (mobile-aware)
        let pixelsPerDegree = 0;
        // Use smaller tempSpreadPixels for mobile devices to prevent collision
        const isMobile = window.innerWidth <= 700;
        const tempSpreadPixels = isMobile ? 25 : 70;
        const avgTemps = data.data.map((x) => x.avgTempF);
        const lowTemp = Math.min.apply(null, avgTemps);
        const highTemp = Math.max.apply(null, avgTemps);
        const tempSpread = highTemp - lowTemp;
        if (tempSpread > 0) {
            pixelsPerDegree = tempSpreadPixels / tempSpread;
        }

        // Batch DOM updates
        requestAnimationFrame(() => {
            let i = 0;
            for (const interval of data.data) {
                let intervalDate = moment(interval.dateTimeISO, "YYYY-MM-DD HH:mm:ss.SSSSSS-ZZ");
                let dateLabel = (intervalDate.hour() === 0 || i === 0) 
                    ? intervalDate.format("h A[<BR>]ddd") 
                    : intervalDate.format("h A");
                
                updateIfChanged(`day-forecast-interval-${i}-title`, dateLabel);
                updateIfChanged(`day-forecast-interval-${i}-avg-temp`, interval.avgTempF + "°");
                updateIfChanged(`day-forecast-interval-${i}-icon`, interval.weatherIcon);

                const adjustableDiv = getCachedElement(`day-forecast-interval-${i}-adjustable-div`);
                if (adjustableDiv) {
                    adjustableDiv.style.paddingTop = pixelsPerDegree * (highTemp - interval.avgTempF) + "px";
                }

                const snowRegex = /.*:.*:(S|SW|SI|RS|WM|BS)$/g;
                const snow = snowRegex.test(interval.weatherPrimaryCoded);
                const rainRegex = /.*:.*:(R|RW|T|TO|UP|ZR|L|BY|ZY|ZR)$/g;
                const rain = rainRegex.test(interval.weatherPrimaryCoded);

                if (snow) {
                    if (debug) console.log(`Day forecast interval ${i} - snow: `, interval.snowIN);
                    updateIfChanged(`day-forecast-interval-${i}-precip-icon`, "❄");
                    updateIfChanged(`day-forecast-interval-${i}-precip`, interval.snowIN + "\"");
                } else if (rain) {
                    if (debug) console.log(`Day forecast interval ${i} - rain: `, interval.precipIN);
                    updateIfChanged(`day-forecast-interval-${i}-precip-icon`, "⛆");
                    updateIfChanged(`day-forecast-interval-${i}-precip`, interval.precipIN + "\"");
                } else {
                    if (debug) console.log(`Day forecast interval ${i} - no precip`);
                    updateIfChanged(`day-forecast-interval-${i}-precip-icon`, "");
                    updateIfChanged(`day-forecast-interval-${i}-precip`, interval.pop + "%");
                }
                i++;
            }

            const lastUpdated = moment(data.lastUpdated, "YYYY-MM-DD HH:mm:ss.SSSSSS-ZZ").format("h:mm A, DD MMM YYYY");
            updateIfChanged('forecast-day-last-updated', "Last Updated: " + lastUpdated);
        });

        setTimeout(refreshDayForecastData, FORECAST_REFRESH_INTERVAL);
    } catch (error) {
        if (debug) console.error("Failed to fetch day forecast data:", error);
        setTimeout(refreshDayForecastData, 60000); // Retry in 1 minute
    }
}

// Generic chart creation function
function createChart(chartName, targetDiv, data, title, options = {}) {
    const { yAxisTitle, chartType = 'spline', tooltipFormat, additionalSeries = [] } = options;
    const config = {
        chart: {
            type: chartType,
            style: { fontFamily: 'Inconsolata, monospace' },
            events: { load: () => markAsRendered(chartName) }
        },
        title: { text: title },
        credits: { enabled: false },
        legend: { enabled: additionalSeries.length > 0 },
        xAxis: {
            type: 'datetime',
            dateTimeLabelFormats: { hour: '%l %p', minute: '%I:%M %p' }
        },
        yAxis: chartType === 'vector' ? { visible: false } : { title: { text: yAxisTitle } },
        time: { useUTC: false },
        series: [
            {
                name: title,
                data,
                color: '#c1121f', // Red
                ...(tooltipFormat && { tooltip: tooltipFormat })
            },
            ...additionalSeries
        ]
    };
    return Highcharts.chart(targetDiv, config);
}

// Mark a chart as rendered
async function markAsRendered(chartName) {
    chartList[chartName].rendered = true;
}
